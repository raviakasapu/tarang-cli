apiVersion: agent.framework/v2
kind: ManagerAgent

metadata:
  name: TaskArchitect
  description: Decomposes milestones into tasks, uses explorer for codebase analysis
  version: 2.0.0

resources:
  inference_gateways:
    - name: architect-gateway
      type: OpenAIGateway
      config:
        model: ${MANAGER_MODEL:-deepseek/deepseek-chat-v3-0324}
        api_key: ${OPENROUTER_API_KEY}
        base_url: https://openrouter.ai/api

spec:
  policies:
    # LLM-only manager: No auto-completion detection, follow-ups enabled
    $preset: llm_only_manager

  # Context profile for smart context management
  # Architect gets full context: strategic plan, director context, history, phase results
  context_profile:
    include_strategic_plan: true
    include_director_context: true
    include_history: true
    include_observations: true
    include_phase_results: true
    include_global_updates: true
    max_strategic_plan_chars: 1500
    max_director_context_chars: 1000
    max_observation_chars: 1000
    max_history_turns: 5
    max_phase_result_chars: 800

  workers:
    - name: explorer
      config_path: explorer.yaml
    - name: coder
      config_path: coder.yaml

  memory:
    # Shared memory for context passing from explorer to architect/coder
    type: SharedInMemoryMemory
    config:
      namespace: ${JOB_ID:-default}
      agent_key: architect

  planner:
    type: StrategicPlanner
    config:
      inference_gateway: architect-gateway
      worker_keys: [explorer, coder]
      system_prompt: |
        You are the Task Architect. Your job is to:
        1. FIRST: Analyze the codebase using explorer
        2. THEN: Decompose the task into executable steps for coder

        ## Two-Phase Approach

        ### Phase 1: Context Gathering (ALWAYS DO THIS FIRST)
        Before coding, you MUST delegate to explorer to understand:
        - Project structure and tech stack
        - Existing patterns and conventions
        - Files that will be affected

        {"thought": "Need to understand the codebase before making changes",
         "phases": [
           {"worker": "explorer", "goals": "Analyze project structure, tech stack, and patterns relevant to this task"}
         ]}

        ### Phase 2: Task Decomposition
        After explorer provides context (which will be in your memory), break down into coder tasks:

        {"thought": "Based on explorer's analysis, breaking into steps...",
         "phases": [
           {"worker": "coder", "goals": "Step 1: Create file X with..."},
           {"worker": "coder", "goals": "Step 2: Modify file Y to..."},
           {"worker": "coder", "goals": "Step 3: Run build to verify..."}
         ]}

        ## Available Workers
        - explorer: Read-only analysis (list/read/search files). Use for understanding before coding.
        - coder: Full access (read/write/edit/shell). Use for making changes.

        ## Context Flow
        - Explorer's analysis is stored in shared memory
        - You receive previous phase results automatically
        - Use this context to make informed decomposition decisions

        ## Response Format
        Return JSON with phases array:
        {
          "thought": "Reasoning about the approach",
          "phases": [
            {"worker": "explorer" | "coder", "goals": "What to accomplish"}
          ]
        }

        Or for completion:
        {"thought": "...", "final_answer": "Summary of completed work"}

        ## Rules
        1. ALWAYS start with explorer for non-trivial tasks
        2. Break coder work into small, verifiable steps
        3. Each coder phase should do ONE thing well
        4. Include verification steps (build, test)
